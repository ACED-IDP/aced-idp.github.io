{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the ACED-IDP Documentation","text":"<p>This documentation will walk you through the steps for submitting data to the ACED-IDP Data Commons.</p> <p>For more on ACED, ie the International Alliance for Cancer Early Detection</p> <p>The International Alliance for Cancer Early Detection (ACED) is a new \u00a355 million partnership between Cancer Research UK, the Canary Center at Stanford University, the University of Cambridge, the Knight Cancer Institute at OHSU, University College London and the University of Manchester.</p> <p>We are uniting world leading researchers to tackle the biggest challenges in early detection, an important area of unmet clinical need. Scientists in the Alliance are working together at the forefront of technological innovation to translate research into realistic ways to improve cancer diagnosis, which can be implemented into health systems and meaningfully benefit people with cancer.</p>"},{"location":"#about","title":"About","text":"<p>The gen3-tracker (g3t) command line utility is a combination of tools that facilitate data sharing on the ACED platform. It allows you to create a unified data project, upload files, and associate those files with metadata in an incremental manner. Submitted data with g3t gives you all the benefits the data platform offers: data indexing, data exploration, consolidated access, and more!</p> <p>The following guide details the steps a data contributor must take to submit a project to the ACED data commons.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To navigate through each page, use pages list in the top left or using the navigation arrow on the bottom left and right! Otherwise, check out our requirements page to get started.</p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Note</p> <p>The tools listed here are under development and may be subject to change.</p> <p>Use case: As an analyst, in order to share data with collaborators, I need a way to create a project, upload files and associate those files with metadata. The system should be capable of adding files in an incremental manner.</p> <p>The following guide details the steps a data contributor must take to submit a project to the ACED data commons.</p> <p>In a Gen3 data commons, a semantic distinction is made between two types of data: \"data files\" and \"metadata\". more</p> <p>A \"data file\" could be information like tabulated data values in a spreadsheet or a fastq/bam file containing DNA sequences. The contents of the file are not exposed to the API as queryable properties, so the file must be downloaded to view its content.</p> <p>\"Metadata\" are variables that help to organize or convey additional information about corresponding data files so that they can be queried via the Gen3 data commons\u2019 API or viewed in the Gen3 data commons\u2019 data exploration tool. In a Gen3 data dictionary, variable names are termed \"properties\", and data contributors provide the values for these pre-defined properties in their data submissions.</p> <p>For the ACED data commons, we have created a data dictionary based on the FHIR data standard. The data dictionary is available here</p>"},{"location":"getting-started/#examples","title":"Examples","text":"<p>In a Gen3 Data Commons, programs and projects are two administrative nodes in the graph database that serve as the most upstream nodes. A program must be created first, followed by a project. Any subsequent data submission and data access, along with control of access to data, is done through the project scope. more</p> <p>For the following examples, we will use the <code>aced</code> program with a project called <code>myproject</code>, please use the <code>g3t projects ls</code> command to verify what programs you have access to.</p>"},{"location":"note/","title":"Note","text":"<p>Note</p> <p>The tools listed here are under development and may be subject to change.</p>"},{"location":"requirements/","title":"Requirements","text":""},{"location":"requirements/#1-download-gen3-client","title":"1. Download gen3-client","text":"<p>gen3-client to upload and download files to the gen3 platform. Since the ACED-IDP is built on gen3, gen3-client is used in gen3-tracker (g3t) for the same purpose. See the instructions below for how to download gen3-client for your operating system.</p>"},{"location":"requirements/#installation-instructions","title":"Installation Instructions","text":"macOSLinuxWindows <ol> <li>Download the macOS version of the gen3-client.</li> <li>Run the gen3-client pkg, following the instructions in the installer.</li> <li>Open a terminal window.</li> <li>Create a new gen3 directory: <code>mkdir ~/.gen3</code></li> <li>Move the executable to the gen3 directory: <code>mv /Applications/gen3-client ~/.gen3/gen3-client</code></li> <li>Change file permissions: <code>chown $USER ~/.bash_profile</code></li> <li>Add the gen3 directory to your PATH environment variable: <code>echo 'export PATH=$PATH:~/.gen3' &gt;&gt; ~/.bash_profile</code></li> <li>Refresh your PATH: <code>source ~/.bash_profile</code></li> <li>Check that the program is downloaded: run <code>gen3-client</code></li> </ol> <ol> <li>Download the Linux version of the gen3-client.</li> <li>Unzip the archive.</li> <li>Open a terminal window.</li> <li>Create a new gen3 directory: <code>mkdir ~/.gen3</code></li> <li>Move the unzipped executable to the gen3 directory: <code>~/.gen3/gen3-client</code></li> <li>Change file permissions: <code>chown $USER ~/.bash_profile</code></li> <li>Add the gen3 directory to your PATH environment variable: <code>echo 'export PATH=$PATH:~/.gen3' &gt;&gt; ~/.bash_profile</code></li> <li>Refresh your PATH: <code>source ~/.bash_profile</code></li> <li>Check that the program is downloaded: run <code>gen3-client</code></li> </ol> <ol> <li>Download the Windows version of the gen3-client.</li> <li>Unzip the archive.</li> <li>Add the unzipped executable to a directory, for example: <code>C:\\Program Files\\gen3-client\\gen3-client.exe</code></li> <li>Open the Start Menu and type \"edit environment variables\".</li> <li>Open the option \"Edit the system environment variables\".</li> <li>In the \"System Properties\" window that opens up, on the \"Advanced\" tab, click on the \"Environment Variables\" button.</li> <li>In the box labeled \"System Variables\", find the \"Path\" variable and click \"Edit\".</li> <li>In the window that pops up, click \"New\".</li> <li>Type in the full directory path of the executable file, for example: <code>C:\\Program Files\\gen3-client</code></li> <li>Click \"Ok\" on all the open windows and restart the command prompt if it is already open by entering cmd into the start menu and hitting enter.</li> </ol>"},{"location":"requirements/#2-configure-a-gen3-client-profile-with-credentials","title":"2. Configure a gen3-client Profile with Credentials","text":"<p>To use the gen3-client, you need to configure  <code>gen3-client</code> with API credentials downloaded from the Profile page.</p> <p></p> <p>Log into the website. Then, download the access key from the portal and save it in the standard location <code>~/.gen3/credentials.json</code></p> <p></p> <p>From the command line, run the gen3-client configure command:</p> Example CommandMac/LinuxWindows <pre><code>gen3-client configure \\\n    --profile=&lt;profile_name&gt; \\\n    --cred=&lt;credentials.json&gt; \\\n    --apiendpoint=https://aced-idp.org\n</code></pre> <pre><code>gen3-client configure \\\n    --profile=aced \\\n    --cred=~/Downloads/credentials.json \\\n    --apiendpoint=https://aced-idp.org\n</code></pre> <pre><code>gen3-client configure \\\n    --profile=aced \\\n    --cred=C:\\Users\\demo\\Downloads\\credentials.json \\\n    --apiendpoint=https://aced-idp.org\n</code></pre> <p>Run the <code>gen3-client auth</code> command to confirm you configured a profile with the correct authorization privileges. Then, to list your access privileges for each project in the commons you have access to:</p> <pre><code>gen3-client auth --profile=aced\n\n# 2023/12/05 15:07:12\n# You have access to the following resource(s) at https://aced-idp.org:\n# 2023/12/05 15:07:12 /programs/aced/projects/myproject...\n</code></pre>"},{"location":"requirements/#3-install-gen3-tracker-g3t","title":"3. Install gen3-tracker (g3t)","text":"<p>The <code>gen3-tracker (g3t)</code> tool requires a working Python 3 installation no older than Python 3.12. Check your version with <code>python3 --version</code>. If needed, download a compatible version of Python 3.</p> <p>Optionally, create a virtual environment using venv or conda for g3t. We will use venv in the instructions.</p> <pre><code>python3 -m venv venv; source venv/bin/activate\n</code></pre> <p>Run the following in your working directory to install the latest version of g3t from the Python Package Index:</p> <pre><code>pip install gen3-tracker\n</code></pre> <p>You can verify the installation was successful by then running the <code>g3t</code> command with the expected output being the latest version:</p> <pre><code>g3t --version\n</code></pre>"},{"location":"requirements/#upgrading-g3t","title":"Upgrading g3t","text":"<p>This version should match the latest version on the PyPi page. If it is out of date, run the following to upgrade your local version:</p> <pre><code>pip install -U gen3-tracker\n</code></pre>"},{"location":"requirements/#configuration","title":"Configuration","text":"<p>g3t uses the gen3-client configuration flow.</p> <p>After configuration, you can either specify the <code>--profile</code> or set the <code>G3T_PROFILE=profile-name</code> environmental variable.</p>"},{"location":"requirements/#testing-the-configuration","title":"Testing the configuration","text":"<p>The command <code>g3t ping</code> will confirm that the access key and gen3-client have been configured correctly</p> <pre><code>g3t --profile aced ping\n</code></pre> <p>A successful ping will output something like:</p> <p>msg: 'Configuration OK: Connected using profile:aced'</p> <p>endpoint: https://aced-idp.org</p> <p>username: someone@example.com</p> <p>bucket_programs:</p> <p>...</p> <p>your_access:</p> <p>...</p> <p>With g3t completely set up, see the Quickstart Guide for how to upload and download data to a project.</p>"},{"location":"data-model/integration/","title":"Integrating your data","text":"<p>Converting tabular data (CSV, TSV, spreadsheet, database table) into FHIR (Fast Healthcare Interoperability Resources) involves several steps to map the data in the spreadsheet to FHIR's resource structure. Here is what you need to know to get started:</p> <p>As you create a upload files, you can tag them with identifiers which by default will create minimal, skeleton graph.</p> <p>You can retrieve that data using the g3t command line tool, and update the metadata to create a more complete graph representing your study.</p> <p>You may choose to work with the data in it's \"native\" json format, or convert it to a tabular format for integration.  The system will re-convert tabular data back to json for submittal.</p> <p>The process of integrating your data into the graph involves several steps:</p> <ul> <li> <p>Step 1: Identify Data and FHIR Resources</p> <ul> <li>Inventory tabular data: Review the spreadsheet to understand the types of data it contains (e.g., patient demographics, lab results, medications).</li> <li>Understand FHIR Resources: Familiarize yourself with FHIR resources relevant to the data in your spreadsheet (e.g., Patient, Observation, Specimen, etc.).</li> </ul> </li> <li> <p>Step 2: Mapping Spreadsheet Columns to FHIR Fields</p> <ul> <li>Analyze Columns: Map each column in the spreadsheet to corresponding fields in FHIR resources. For instance, you may have a field called biopsy_anatomical_location with content of \"Prostate needle biopsies\", that would map to Specimen.collection.method and Specimen.collection.bodySite.</li> <li>Handle Relationships: Identify how different pieces of data relate to each other and how they map to FHIR resource relationships (e.g., linking patients to their observations).</li> </ul> </li> <li> <p>Step 3: Data Transformation and Structure</p> <ul> <li>Prepare Data: Ensure data consistency and format alignment. Dates, codes, and identifiers should comply with FHIR standards.</li> <li>Normalize Data: Split the spreadsheet data into FHIR-compliant resources.</li> </ul> </li> <li> <p>Step 4: Utilize provided FHIR Tooling or Libraries</p> <ul> <li>FHIR Tooling: Use <code>g3t  meta dataframe</code> and associated libraries to support data conversion and validation.</li> <li>Validation: Use <code>g3t  meta validate</code> to validate the transformed data against FHIR specifications to ensure compliance and accuracy.</li> </ul> </li> <li> <p>Step 5: Import into FHIR-Compatible System</p> <ul> <li>Load Data: Use <code>g3t commit</code> to load the transformed data into the aced system.</li> <li>Testing and Verification: Use <code>g3t push</code> to ensure your data appears correctly in the portal and analysis tools.</li> </ul> </li> <li> <p>Step 6: Iterate and Refine</p> <ul> <li>Review and Refine: Check for any discrepancies or issues during the import process. Refine the conversion process as needed.</li> <li>Feedback Loop: Gather feedback from users or stakeholders to improve the mapping and conversion process.</li> </ul> </li> </ul>"},{"location":"data-model/integration/#ontologies","title":"Ontologies","text":"<p>Ontologies within FHIR serve as a formal representation of concepts, their relationships, and properties within the healthcare domain. They provide a shared vocabulary and framework that enable consistent interpretation and exchange of healthcare data among different systems and entities.</p> <p>FHIR utilizes ontologies in various ways:</p> <ul> <li> <p>Terminology Binding: Ontologies help define and bind standardized terminologies to FHIR resources. This ensures that data elements, such as diagnoses or procedures, are uniformly understood across different studies or submissions.</p> </li> <li> <p>Code Systems: FHIR employs standardized code systems (like SNOMED CT, LOINC, or RxNorm) within its resources. These code systems are essentially ontologies that define concepts and relationships, allowing for precise identification and categorization of medical information.</p> </li> <li> <p>Mapping and Alignment: Ontologies assist in mapping data between different standards and formats. They facilitate the alignment of disparate data representations by providing a common reference point, making it easier to convert and interpret information accurately across systems.</p> </li> <li> <p>Semantic Interoperability: By using ontologies, FHIR promotes semantic interoperability. This means that not only can systems exchange data but also understand the meaning behind the exchanged information, enhancing communication and reducing ambiguity in healthcare data exchange.</p> </li> <li> <p>Consistency and Reusability: Ontologies establish a consistent and reusable framework for defining healthcare concepts. This consistency aids in data integration, analytics, and the development of applications or systems that can leverage shared knowledge.</p> </li> </ul> <p>In essence, ontologies in FHIR serve as the backbone for standardization, enabling effective communication and interpretation of healthcare data among various stakeholders, systems, and applications.</p>"},{"location":"data-model/integration/#example-snomed-ct","title":"Example: SNOMED CT","text":"<p>The Specimen resource in FHIR represents a sample or specimen collected during a healthcare event and contains details about its origin, type, and processing.</p> <p>Mapping a SNOMED body part to a FHIR Specimen involves linking the anatomical or body site specified in SNOMED CT to the relevant information within a FHIR Specimen resource.</p> <p></p> <p>The mapping process typically involves several steps:</p> <ul> <li> <p>Identification of SNOMED CT Body Part: SNOMED CT contains a comprehensive hierarchy of anatomical structures and body parts. This could include specific codes representing organs, tissues, or body sites.</p> </li> <li> <p>Mapping to FHIR Specimen: In FHIR, the Specimen resource includes fields like specimen type, collection details, container, and possibly body site information.</p> </li> <li> <p>Matching Concepts: The SNOMED CT code representing the body part or anatomical site needs to be correlated with the relevant field(s) in the FHIR Specimen resource. For instance, the FHIR Specimen resource has a field called \"collection.bodySite\" that can be used to capture the anatomical location from which the specimen was obtained.</p> </li> </ul>"},{"location":"data-model/integration/#identifiers","title":"Identifiers","text":"<p>Identifiers in FHIR references typically include the following components: see more</p> <p>A string, typically numeric or alphanumeric, that is associated with a single object or entity within a given system. Typically, identifiers are used to connect content in resources to external content available in other frameworks or protocols.</p> <p>System: Indicates the system or namespace to which the identifier belongs. By default the namespace is <code>http://aced-idp.org/&lt;project-id&gt;</code>.</p> <p>Value: The actual value of the identifier within the specified system. For instance, a lab controlled subject identifier or a specimen identifier.</p>"},{"location":"data-model/integration/#references","title":"References","text":"<p>By using identifiers in references, FHIR ensures that data can be accurately linked, retrieved, and interpreted across different systems and contexts within the healthcare domain, promoting interoperability and consistency in data exchange. see more</p> <p>Many of the defined elements in a resource are references to other resources. Using these references, the resources combine to build a web of information about healthcare.</p>"},{"location":"data-model/integration/#key-resources","title":"Key resources","text":""},{"location":"data-model/integration/#researchstudy","title":"ResearchStudy","text":"<p>A scientific study of nature that sometimes includes processes involved in health and disease. see more</p>"},{"location":"data-model/integration/#researchsubject","title":"ResearchSubject","text":"<p>A ResearchSubject is a participant or object which is the recipient of investigative activities in a research study. see more</p>"},{"location":"data-model/integration/#patient","title":"Patient","text":"<p>Demographics and other administrative information about an individual or animal receiving care or other health-related services. see more</p>"},{"location":"data-model/integration/#specimen","title":"Specimen","text":"<p>A sample to be used for analysis. see more</p>"},{"location":"data-model/integration/#documentreference","title":"DocumentReference","text":"<p>A reference to a document of any kind for any purpose. see more</p> <p>See the  metadata workflow section for more information on how to create and upload metadata.</p>"},{"location":"data-model/introduction/","title":"FHIR for Researchers","text":"<p>Given all of the intricacies healthcare and experimental data, we use Fast Healthcare Interoperability Resources (FHIR) as a data model to ensure informaticians and analysts can concentrate on science, not data structures.  This document introduces model for Research Analysts and describes how an analyst can shape and query FHIR resources.</p>"},{"location":"data-model/introduction/#what-is-fhir","title":"What is FHIR?","text":"<p>In an era where healthcare information is abundant yet diverse and often siloed, FHIR emerges as a standard, empowering research analysts to navigate, aggregate, and interpret health data seamlessly. This guide aims to unravel the intricacies of FHIR, equipping research analysts with the knowledge and tools needed to harness the potential of interoperable healthcare data for insightful analysis and impactful research outcomes in the context of ACED collaborations.</p>"},{"location":"data-model/introduction/#graph-model","title":"Graph Model","text":"<p>FHIR has certain aspects that can align with graph-like structures or facilitate graph-based analysis:</p> <p>Resource Relationships: FHIR resources often have relationships with other resources. For instance, a Patient resource can be associated with multiple Observation resources, which in turn might be linked to Condition or Procedure resources. These relationships create a network-like structure, similar to a graph.</p> <p>References and Linkages: FHIR resources utilize references to establish connections between related entities. These references can be leveraged to create graph-like representations when modeling relationships between patients, specimens, observations, etc.</p>"},{"location":"data-model/introduction/#example","title":"Example","text":"<p>The following \"file focused\" example illustrates how ACED uses FHIR resources a DocumentReference's ancestors within a study.</p> <p>Examine resource definitions here:</p> <ul> <li> <p>Details on uploaded files are captured as DocumentReference</p> </li> <li> <p>DocumentReference.subject indicates who or what the document is about:  </p> </li> <li>Can simply point to the ResearchStudy, to indicate the file is part of the study</li> <li>Can point to Patient, or Specimen, to indicate the file is based on them</li> <li>An Observation can point to any entity    </li> <li>A Task can provide provenance on how the file was created </li> </ul> <p>Each resource has at least one study controlled official Identifier.  Child resources have Reference fields to point to their parent.</p> <p></p>"},{"location":"workflows/add-files/","title":"Adding Files","text":"<p>Note</p> <p>The tools listed here are under development and may be subject to change.</p>"},{"location":"workflows/add-files/#background","title":"Background","text":"<p>Adding files to a project is a two-step process:</p> <ol> <li>Adding file metadata entries to the manifest</li> <li>Creating FHIR-compliant metadata using the manifest</li> </ol> <p>This page will guide you through the first step, detailing the multiple ways to add file metadata to the manifest.</p>"},{"location":"workflows/add-files/#overview","title":"Overview","text":"<p>A manifest is a collection of file metadata entries. Just as a ship's manifest is an inventory of its cargo, the <code>MANIFEST/</code> directory is an inventory of your file metadata. We update that manifest using <code>g3t add</code>. When you <code>g3t add</code> a file, an entry is written to a  <code>.dvc</code> file in the <code>MANIFEST</code> directory, where the dvc file path mirrors the original file path relative to the root of the project. For instance, <code>g3t add path/to/file.txt</code> writes an entry to <code>MANIFEST/path/to/file/txt</code>. This manifest is then used by <code>g3t meta init</code> to create FHIR-complaint metadata used to populate the data platform.</p> <p>Here are a couple ways to add file metadata to the manifest.</p>"},{"location":"workflows/add-files/#adding-a-local-file-to-the-manifest","title":"Adding a local file to the manifest","text":"<p>To add a single file from your current working directory to the manifest,</p> <pre><code>g3t add path/to/file\n</code></pre> <p>In this command, <code>g3t</code> creates a metadata entry for the specified data file, automatically calculating metadata like the file's md5sum, type, date modified, size, and path.</p>"},{"location":"workflows/add-files/#adding-a-remote-file-to-the-manifest","title":"Adding a remote file to the manifest","text":"<p>Sometimes you might want to generate metadata for a remote file. To add a file in an Amazon S3 bucket to the manifest,</p> <pre><code>g3t add s3://&lt;Bucket&gt;/&lt;File&gt; \\\n --etag {ETag} \\\n  --modified {system_time} \\\n --size {system_size} \\\n  {static_parameters}\n</code></pre> <p>Since the file is not localized, we need to manually provide some file information, specifically... 1. Hash: a unique fixe-length string generated from the file's contents    1. <code>etag</code> is used here but <code>md5</code>, <code>sha1</code>, <code>sha256</code>, <code>sha512</code>, and <code>crc</code> are also valid. 2. Date modified: Date modified in system time 3. Size: File size in bytes</p> <p>To get the ETag, size, and date modified for a remote file mirrored on S3, run the following <code>mc stat</code> command using the MinIO client: <pre><code>mc stat --json ceph/example-bucket/example.bam\n{\n \"status\": \"success\",\n \"name\": \"example.bam\",\n \"lastModified\": \"2024-02-21T09:20:24-08:00\",\n \"size\": 148299010745,\n \"etag\": \"17a5275404b41f52b042b43eb351f5ba-8840\",\n \"type\": \"file\",\n \"metadata\": {\n  \"Content-Type\": \"application/gzip\"\n }\n}\n</code></pre></p> <p>Then to add the remote file, run the following:</p> <pre><code>g3t add s3://example-bucket/file.bam \\\n --etag \"17a5275404b41f52b042b43eb351f5ba-8840\" \\\n  --size 148299010745 \\\n --modified \"2024-02-21T09:20:24-08:00\" \\\n</code></pre>"},{"location":"workflows/add-files/#modifying-an-existing-file-in-the-manifest","title":"Modifying an existing file in the manifest","text":"<p>You can use <code>g3t add</code> to also modify existing files that are already tracked in the manifest. When you do so, the <code>g3t add</code> command will maintain the existing information and update any values that are passed in as flags. For local files, it will re-populate the file metadata according to its current state in the repo. For remote files, you will have to manually update those fields yourself.</p>"},{"location":"workflows/add-files/#associating-files-with-other-entities","title":"Associating files with other entities","text":"<p>In some cases, you might want to associate a file to a particular entity like a subject or sample. This can be done with a flag:</p> <pre><code>g3t add path/to/file --patient patient_abc\ng3t add path/to/file --specimen specimen_001\n</code></pre> <p>The flag name corresponds to a type of FHIR resource specifically either a patient, specimen, task, or observation. The info passed into the command after the flag represents the identifier that will be used to group file data on a patient. This can be combined with the above methods as an additional flag.</p>"},{"location":"workflows/add-files/#adding-multiple-files-to-the-manifest","title":"Adding multiple files to the manifest","text":"<p>Adding multiple files at once is possible as well, here are some examples</p> <pre><code>g3t add \"dir/*\" # recursively add all files in the top level of dir directory to manifest\ng3t add \"*.txt\" # add all .txt files in the current directory to manifest\n</code></pre> <p>Make sure to surround your wildcard string in quotes, as it will only add the first matching file otherwise.</p>"},{"location":"workflows/add-files/#migration-of-existing-project-files","title":"Migration of existing project files","text":"<p>If you have an existing project that you want to migrate using g3t, you can do so by following these steps:</p> <ul> <li>Create a new repository using <code>g3t init</code>. See Creating a project</li> <li>Either move or copy your existing data files into the new repository.  Alternatively, symbolic links are supported.</li> </ul>"},{"location":"workflows/add-files/#a-note-on-data-directories","title":"A note on data directories","text":"<p>When creating metadata, all paths referring to data directories are stored relative to the root of the project. For instance, when doing <code>g3t add path/to/file.txt</code>, the output is stored in <code>MANIFEST/path/to/file.txt</code>. Here's a brief explanation of this convention:</p> <ul> <li>Portability: Relative paths make your project more portable, allowing it to be moved to different locations or shared with others without causing issues with file references. This is particularly important in data engineering projects where datasets and files may be stored in different locations.</li> <li>Ease of Collaboration: When working on a data engineering project with multiple team members, using relative paths ensures that everyone can run the code without having to modify file paths based on their local directory structure. This promotes smoother collaboration.</li> <li>Consistency Across Environments: Data engineering projects often involve processing large datasets, and the code needs to run consistently across different environments (e.g., development, testing, production). Relative paths help maintain this consistency by allowing the code to reference files and directories relative to the project's root.</li> </ul>"},{"location":"workflows/add-files/#next-steps","title":"Next steps","text":"<ul> <li>See metadata workflow for more information on how to create and upload metadata.</li> </ul>"},{"location":"workflows/add-users/","title":"Add users","text":""},{"location":"workflows/add-users/#granting-user-access-to-a-project","title":"Granting user access to a project","text":"<p>Once a project has been created you will have full access to it.  The project owner can add additional users to the project using the <code>g3t collaborator</code> commands.</p> <p>There are two ways to request the addition additional users to the project:</p>"},{"location":"workflows/add-users/#1-read-and-write-access","title":"1. Read and Write Access","text":"<p>To give another user full access to the project, run the following:</p> <pre><code>g3t collaborator add --write  user-can-write@example.com\n</code></pre> <p>Alternatively, to give another user read access only (without the ability to upload to the project), run the following: <pre><code>g3t collaborator add user-read-only@example.com\n</code></pre></p>"},{"location":"workflows/add-users/#2-approvals","title":"2.  Approvals","text":"<p>In order to implement these requests, an authorized user will need to sign the request before the user can use the remote repository. See <code>g3t collaborator approve --help</code></p>"},{"location":"workflows/approve-requests/","title":"Role Based Access Control","text":""},{"location":"workflows/approve-requests/#creating-a-new-project","title":"Creating a new project","text":"<ul> <li>Any user may request a project be added to the institution's program.</li> <li>The user who requested the project is automatically given the read and write roles.</li> <li>Ony users with the data steward role  can approve and sign a request</li> <li>An administrator must create the project in the repository</li> </ul>"},{"location":"workflows/approve-requests/#adding-a-new-user-to-a-project","title":"Adding a new user to a project","text":"<ul> <li>Any user may request a user be added to a project.</li> <li>The <code>--write</code> flag will grant the user write access to the project.</li> <li>Ony users with the steward role can approve and sign a request</li> </ul> <pre><code>g3t collaborator approve --help\nUsage: g3t collaborator approve [OPTIONS]\n\n  Sign an existing request (privileged).\n\nOptions:\n  --request_id TEXT  Sign only this request\n  --all              Sign all requests\n  --help             Show this message and exit.\n</code></pre>"},{"location":"workflows/approve-requests/#use-case","title":"Use case","text":""},{"location":"workflows/approve-requests/#adding-data-access-committee-members","title":"Adding Data Access Committee members","text":"<p>Note: This example uses the ohsu program, but the same process applies to all programs.</p> <ul> <li>A sysadmin will add the requestor role to a data-access-committee member(s) aka data steward</li> <li>Only users with the requestor role can APPROVE and SIGN adding policies within their program</li> </ul> <pre><code>## As an admin, I need to grant data steward privileges add the requester reader and updater role on a program to an un-privileged user\ng3t collaborator add  add data_steward_example@&lt;institution&gt;.edu --resource_path /programs/&lt;program_name&gt;/projects  --steward\n# As an admin, approve that request\ng3t collaborator approve\n</code></pre> <p>There are several institutions that are contributing data to ACED. Each institution has a different set of data access policies.  Each may have different requirements for how data is accessed, and who can access it.  Importantly, each institution may have individual who approves access to data.</p> <p></p>"},{"location":"workflows/approve-requests/#solution","title":"Solution","text":"<p>We use Gen3's role based access control (RBAC) to manage access to data.</p> <ul> <li>There is a separate <code>program</code> resource for each institution:</li> <li>/programs/ohsu</li> <li>/programs/stanford</li> <li>/programs/ucl</li> <li>/programs/manchester</li> </ul> <p>Designated users within each institution have privileges to update requests. \"Update\" in this context means setting the status of a user's request to [SIGNED].</p> <p>Since this approach relies on Gen3's Requestor for all assignments of policies to users we get  the following benefits:</p> <ul> <li>Tooling (command line for now, web page in the future) leverages requestor API</li> <li>Auditing of data access requests is done by requestor</li> </ul>"},{"location":"workflows/clone/","title":"Cloning a Project","text":"<p>The <code>g3t clone</code> command is used to clone a project from the remote repository. Here's a brief explanation of what happens when you use g3t clone:</p> <ul> <li>A subdirectory is created for the project, it is named after the <code>project_id</code>.</li> <li>The project is initialized locally, including the <code>.g3t</code> and <code>META</code> directories.</li> <li>The current metadata is downloaded from the remote repository.  </li> <li>By default, data files are not downloaded by default</li> </ul> <pre><code>g3t clone --help\nUsage: g3t clone [OPTIONS] PROJECT_ID\n\n  Clone meta and files from remote.\n\nOptions:\n  --help  Show this message and exit.\n</code></pre>"},{"location":"workflows/commit-push/","title":"Publishing a Project","text":"<p>The following page will outline how to publish your project to the data platform.</p>"},{"location":"workflows/commit-push/#committing-changes","title":"Committing Changes","text":"<p>The <code>g3t commit</code> command saves your changes to the local repository. Here's a brief explanation of what happens when you use g3t commit:</p> <ul> <li>Like git, this command bundles the staged files into a single set of changes.</li> <li>The <code>-m</code> flag provides a commit message detailing the changes </li> <li>If the commit is successful, you will see a summary of the changes logged</li> <li>As a reminder, the files committed to git are the FHIR metadata in <code>META/</code> and the file metadata entries in <code>MANIFEST/</code>, not the data files themselves.</li> <li>See <code>g3t commit --help</code> for more info</li> </ul> <p>You can confirm all your changes have been staged and committed using <code>g3t status</code>. This will ensure that your manifest data and FHIR metadata is up to date.</p>"},{"location":"workflows/commit-push/#pushing-changes","title":"Pushing Changes","text":""},{"location":"workflows/commit-push/#how-to-push-changes","title":"How to Push Changes","text":"<p>The <code>g3t push</code> command uploads your changes to the data platform. Here's a brief explanation of what happens when you use <code>g3t push</code>:</p> <ol> <li>Checks that all files are committed before pushing</li> <li>Checks that the FHIR metadata in <code>META/</code> is valid</li> <li>Indexes the data files using the file metadata in the <code>MANIFEST/</code> directory</li> <li>Uploads the FHIR metadata to our databases</li> <li>Once the job is complete:<ul> <li>Changes are available on the platform</li> <li>Changes are available for other users to download</li> <li>Job logs are available in the logs directory</li> </ul> </li> </ol>"},{"location":"workflows/commit-push/#updating-files","title":"Updating Files","text":"<p>When pushing data, <code>g3t</code> checks the manifest (<code>MANIFEST/</code> directory) to see if there are any new files to index. If no new files have been added, then the push will not go through. To update the metadata for a file that has already been pushed or update the FHIR metadata, use the <code>--overwrite</code> flag:</p> <pre><code>$ g3t push --overwrite\n</code></pre>"},{"location":"workflows/commit-push/#logging","title":"Logging","text":"<p>Make sure to check the logs generated by the command.</p> <ul> <li>If a job is successful, you will get a green success message.</li> <li>If a job fails, you will get a red error message: look for more information in the specified logs directory.</li> <li>The logs directory stores rolling logs, where each line is a JSON representing a single submission attempt.</li> </ul>"},{"location":"workflows/common-errors/","title":"Common Errors","text":""},{"location":"workflows/common-errors/#ndjson-is-out-of-date","title":".ndjson is out of date","text":"<p>Error: After <code>g3t</code> adding and committing a file, when you go to submit your data, \"DocumentReference.ndjson is out of date\", <pre><code>$ g3t add file.txt\n$ g3t commit -m \"adding file.txt\"\n$ g3t push\nPlease correct issues before pushing.\nCommand `g3t status` failed with error code 1, stderr: WARNING: DocumentReference.ndjson is out of date 1969-12-31T16:00:00. The most recently changed file is MANIFEST/file.txt.dvc 2025-02-28T09:24:46.283870.  Please check DocumentReferences.ndjson\nNo data file changes.\n</code></pre></p> <p>Resolution: As well as checking that all files are committed, <code>g3t status</code> also ensures that FHIR metadata in <code>META/</code> is up to date. This means that you likely missed a crucial step in the process, updating the FHIR metadata using the file manifest! The general flow for adding file metadata is <code>g3t add</code> &gt; <code>g3t meta init</code> &gt; <code>g3t commit</code>. To resolve this, update and commit the FHIR metadata:</p> <pre><code>$ g3t meta init\nUpdated 2 metadata files.\nresources={'summary': {'DocumentReference': 1, 'ResearchStudy': 1}} exceptions=[]\n\n$ g3t push\n</code></pre> <p>To better understand the process of adding file metadata through the manifest, see adding file metadata and adding FHIR metadata.</p>"},{"location":"workflows/common-errors/#no-new-files-to-index","title":"No new files to index","text":"<p>Error: <pre><code>$ g3t push\nNo new files to index.  Use --overwrite to force\n</code></pre></p> <p>Resolution: When pushing data, <code>g3t</code> checks the manifest (<code>MANIFEST/</code> directory) to see if there are any files to update, including new files or modified files. If no files have been modified, then the push will not go through. To push up the same file data or push up new FHIR metadata (<code>META/</code>), use <code>g3t push --overwrite</code></p>"},{"location":"workflows/common-errors/#uncommitted-changes","title":"Uncommitted changes","text":"<p>Error: On the subsequent rounds of adding files, updating FHIR metadata, and committing the changes, you are unable to push up those new changes <pre><code>$ g3t add hello.txt\n$ g3t meta init\n$ g3t commit -m \"add hello file\"\n\n$ g3t push\nUncommitted changes found.  Please commit or stash them first.\n\n$ g3t status\nNo data file changes.\nOn branch main\nChanges not staged for commit:\n ...\n modified:   META/DocumentReference.ndjson\n</code></pre></p> <p>Resolution: This happened because the update FHIR metadata created in the META init was not staged for commit. To stage and commit the FHIR metadata, do:</p> <pre><code>$ git add META/\n$ g3t commit -m \"update DocumentReference.json\"\n$ g3t push\n</code></pre> <p>Note that <code>git add</code> is used here rather than <code>g3t add</code> because <code>git add</code> will update the project's FHIR metadata while <code>g3t add</code> only updates the project's manifest. If you want to commit multiple file changes, you can also use <code>g3t commit -am \"update all files\"</code>, where all changes get committed to the project.</p>"},{"location":"workflows/creating-project/","title":"Creating a Project","text":"<p>Note</p> <p>The tools listed here are under development and may be subject to change.</p>"},{"location":"workflows/creating-project/#cli","title":"CLI","text":"<pre><code>$ g3t init --help\n\nUsage: g3t init [OPTIONS] [PROJECT_ID]\n\n  Initialize a new repository.\n\nOptions:\n  --debug        Enable debug mode. G3T_DEBUG environment variable can also be used.\n  --help         Show this message and exit.\n</code></pre>"},{"location":"workflows/creating-project/#overview","title":"Overview","text":"<p>The <code>g3t init</code> command initializes a new project in your current working directory. It works with existing files in the directory and creates a couple important directories:</p> <ul> <li><code>.g3t/</code>: a hidden directory within your project that houses the internal data structure required for version control.</li> <li><code>META/</code>: a visible directory within your project that houses the FHIR metadata files.</li> <li><code>MANIFEST/</code>: a visible directory within your project that houses additional file-specific metadata.</li> </ul> <p>An initialized project will look something like this...</p> <pre><code>.\n\u251c\u2500\u2500 .g3t                                  // g3t project state\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 state\n\u251c\u2500\u2500 .git                                  // git repository state\n\u251c\u2500\u2500 META                                  // metadata in FHIR format\n\u251c\u2500\u2500 MANIFEST\n\u2514\u2500\u2500 &lt;your data here&gt;                      // existing data files maintained\n \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"workflows/creating-project/#choosing-a-project-id","title":"Choosing a Project ID","text":"<p>A project ID initializes a unique project, taking the form of &lt;program&gt;-&lt;project&gt;. A project ID is significant because it determines the location of the remote repository, bucket storage, and access control. Project IDs have a set of constraints, particularly the program name is predefined by the institution, while the project name must be unique within the server and alphanumeric without spaces. Contact an admin for a list of supported program names.</p>"},{"location":"workflows/creating-project/#authorization","title":"Authorization","text":"<p>While you can work with an initialized repository locally, an authorized user will need to sign the project request before you can push your project to the data platform. You can confirm your project authorization with <code>g3t ping</code></p>"},{"location":"workflows/creating-project/#next-steps","title":"Next steps","text":"<ul> <li>Adding data to a project</li> </ul>"},{"location":"workflows/metadata/","title":"Adding FHIR metadata","text":""},{"location":"workflows/metadata/#background","title":"Background","text":"<p>Adding files to a project is a two-step process:</p> <ol> <li>Adding file metadata entries to the manifest (see adding files)</li> <li>Creating FHIR-compliant metadata using the manifest</li> </ol> <p>This page will guide you through the second step of generating FHIR metadata in your g3t project. To understand the FHIR data model, see FHIR for Researchers</p>"},{"location":"workflows/metadata/#generating-fhir-data-using-g3t","title":"Generating FHIR Data using g3t","text":"<p>To submit metadata from the manifest to the platform, that metadata needs to be converted into FHIR standard. We will use the file metadata entries we had created during the <code>g3t add</code> on our data files.</p>"},{"location":"workflows/metadata/#creating-metadata-files-using-the-manifest","title":"Creating metadata files using the manifest","text":"<p>Using the file metadata entries created by the <code>g3t add</code> command, <code>g3t meta init</code> creates FHIR-compliant metadata files in the <code>META/</code> directory, where each file corresponds to a FHIR resource. At a minimum, this directory will create:</p> File Contents ResearchStudy.ndjson Description of the project DocumentReference.ndjson File information <p>Depending on if a <code>patient</code> or <code>specimen</code> flag was specified, other resources can be added to the metadata files:</p> <ul> <li>subjects (ResearchSubject, Patient)</li> <li>specimens (Specimen)</li> <li>assays (Task)</li> <li> <p>measurements (Observation)</p> </li> <li> <p>This command will create a skeleton metadata file for each file added to the project using the <code>patient</code>, <code>specimen</code>, <code>task</code>, and/or <code>observation</code> flags specified by the <code>g3t add</code> command.  </p> </li> <li>You can edit the metadata to map additional fields.</li> <li>The metadata files can be created at any time, but the system will validate them before the changes are committed.</li> <li>Note: If an existing file is modified, it won't get automatically staged</li> <li>For instance, if <code>DocumentReference.json</code> is already created and it has to be updated to reflect an additional file, this change is not automatically staged.</li> <li>Make sure to either <code>git add META/</code> or use the <code>-a</code> flag in <code>g3t commit</code> to ensure that your FHIR metadata changes are staged.</li> </ul>"},{"location":"workflows/metadata/#example","title":"Example","text":"<p>To add a cram file that's associated with a subject, sample, and particular task</p> <pre><code>g3t add myfile.cram  --patient P0 --specimen P0-BoneMarrow --task_id P0-Sequencing\ng3t meta init\n</code></pre> <p>This will produce metadata with the following relationships:</p> <p></p> <p>When the project is committed, the system will validate new or changed records. You may validate the metadata on demand by:</p> <pre><code>$ g3t  meta validate --help\nUsage: g3t meta validate [OPTIONS] DIRECTORY\n\n  Validate FHIR data in DIRECTORY.\n</code></pre>"},{"location":"workflows/metadata/#rationale-for-the-meta-directory","title":"Rationale for the <code>META</code> directory","text":"<p>All FHIR metadata is housed in the <code>META/</code> directory. The convention of using a <code>META</code> directory for supporting files is common practice in data management. This directory is used to organize and store the metadata files of your project that describe the Study, Subjects, Specimens, Documents, etc. Here's a brief explanation of this convention:</p> <ul> <li>Separation of concerns: The <code>META</code> directory provides a clear separation between your metadata and other project files. This helps maintain a clean and organized project structure.</li> <li>Clarity and Readability: By placing metadata files in a dedicated directory, it becomes easier for researchers (including yourself and others) to locate and understand the main codebase. This improves overall project clarity and readability.</li> <li>Build Tools Integration: Many build tools and development environments are configured by default to recognize the <code>META</code> directory as the main metadata location. This convention simplifies the configuration process and ensures that tools can easily identify and analyze your data files.</li> <li>Consistency Across Projects: Adopting a common convention, such as using <code>META</code> for metadata files, promotes consistency across different projects. When researchers work on multiple projects, having a consistent structure makes it easier to navigate and understand each study.</li> <li>The 'META' directory will contain a file per FHIR resource with the extension .ndjson. e.g. <code>ResearchStudy.ndjson</code> </li> </ul>"},{"location":"workflows/metadata/#supplying-your-own-fhir-metadata","title":"Supplying your own FHIR metadata","text":"<p>In some cases, it might be useful to supply your own FHIR metadata without using <code>g3t add</code> to create any file metadata. In that case, adding metadata would take on the following flow:</p> <ol> <li>Initialize your project</li> <li>Copy external FHIR data as <code>.ndjson</code> files to your <code>META/</code> directory</li> <li><code>git add META/</code></li> <li><code>g3t commit -m \"supplying FHIR metadata\"</code></li> </ol> <p>This process would be useful for individuals who want to use the system to track relations between metadata but might not necessarily want to connect their actual data files to the system.</p>"},{"location":"workflows/metadata/#next-steps","title":"Next Steps","text":"<ul> <li>See the  tabular metadata section for more information on working with metadata.</li> <li>See the  commit and push section for more information on publishing.</li> </ul>"},{"location":"workflows/portal-download/","title":"Download","text":"<p>Note</p> <p>The tools listed here are under development and may be subject to change.</p> <p>There are two main ways to download files:</p> <ol> <li>Individually through the browser or through the command line with the <code>gen3-client</code></li> <li>Batch downloads through the command line with <code>gen3-client</code></li> </ol> <p>This guide will walk you through both methods below.</p>"},{"location":"workflows/portal-download/#download-a-single-file","title":"Download a Single File","text":""},{"location":"workflows/portal-download/#explorer-page","title":"Explorer Page","text":"<p>The easiest way to download a single file is through the Explorer page. This page will show all files belonging to projects that you have access to.</p> <p>To download a single file:</p> <ol> <li>Select the File tab and scroll down to the list of files</li> <li>Select the Download ID for the file of interest</li> </ol> <p></p> <p>3. Select Download on the file page</p> <p></p>"},{"location":"workflows/portal-download/#gen3-client","title":"gen3-client","text":"<p>Alternatively, if you already know the GUID of the file of interest, simply pass it to the gen3-client:</p> <pre><code>gen3-client download-single --profile=aced --guid=&lt;GUID&gt;\n</code></pre> <p>For example, to download the file with GUID <code>f623df8f-5dad-5bce-a8ca-a7b69b7805a5</code>:</p> <pre><code>gen3-client download-single --profile=aced --guid=f623df8f-5dad-5bce-a8ca-a7b69b7805a5\n</code></pre>"},{"location":"workflows/portal-download/#download-multiple-files","title":"Download Multiple Files","text":"<p>To download multiple files:</p> <ol> <li>Select the File tab on the Explorer page</li> <li>Optionally filter by project, data type, and format</li> <li>Select the Download Manifest button</li> </ol> <p></p> <p>4. Download the files by passing the file manifest to the gen3-client:</p> <pre><code>gen3-client download-multiple --profile=aced --manifest=file-manifest.json\n</code></pre> <p>Using the example project in the above screenshot, this command will download all 12 JSON files from the project into the current working directory.</p>"},{"location":"workflows/portal-explore/","title":"Explore","text":"<p>The <code>push</code> command uploads the metadata associated with the project and makes the files visible on the Explorer page.</p> <p></p> <p>See the  portal download for more information on downloading files from the portal.</p>"},{"location":"workflows/query/","title":"Data Querying + Gen3 SDK","text":""},{"location":"workflows/query/#overview","title":"Overview \u2699\ufe0f","text":"<p>Gen3 supports API access to Files and Metadata, allowing users to download and query their data via the Gen3 SDK and GraphQL queries.</p>"},{"location":"workflows/query/#quick-start","title":"Quick Start \u26a1\ufe0f","text":"<p>Adapted from the Gen3 SDK Quick Start page</p>"},{"location":"workflows/query/#1-dependency-and-credentials","title":"1. Dependency and Credentials","text":"<p>Prior to installing, check a profile credentials.  Test: <pre><code>g3t ping \n</code></pre> - will return a list of projects that a profile has access to.</p> <ul> <li> <p>For new setup or renew of gen3 credentials - Follow steps to configure/re-configure a profile with credentials: </p> <ul> <li>Download an API Key from the Profile page and save it to <code>~/.gen3/credentials.json</code></li> </ul> <p></p> <p></p> </li> </ul>"},{"location":"workflows/query/#2-install","title":"2. Install","text":"<p>The Gen3 SDK is available for installation via PyPi:</p> <pre><code>pip install gen3\n</code></pre>"},{"location":"workflows/query/#3-query","title":"3. Query","text":"<p>The following query examples provide a high-level overview on how to use Gen3 python SDK to authenticate, use the authentication to fetch column/metadata names, retrieve entity ids, and then use the ids to make nested queries. Each project would have a graph schema or definition with relations associated that are defined during data transformation or harmonization. The queries would depend on each project's graph definition traversals.   </p>"},{"location":"workflows/query/#30-authenticate","title":"3.0 Authenticate","text":"<pre><code>from gen3.auth import Gen3Auth\nfrom gen3.query import Gen3Query\n\nauth = Gen3Auth() \n</code></pre>"},{"location":"workflows/query/#31-list-available-fields-on-an-entity-to-query-on","title":"3.1 List available fields on an entity to query on","text":"<pre><code>def get_entity_fields(entity_name, auth):\n    \"\"\"Retrieve all field names for a given entity from the Gen3 GraphQL schema.\"\"\"\n    query_template = f\"\"\"\n    {{\n      __type(name: \"{entity_name}\") {{\n        fields {{\n          name\n        }}\n      }}\n    }}\n    \"\"\"\n\n    response = Gen3Query.graphql_query(\n        Gen3Query(auth),\n        query_string=query_template\n    )\n\n    if response and response.get(\"data\", {}).get(\"__type\", {}):\n        fields = response[\"data\"][\"__type\"][\"fields\"]\n        field_names = [field[\"name\"] for field in fields]\n        return field_names\n    else:\n        print(f\"Failed to retrieve fields for {entity_name}:\", response)\n        return []\n\nentity_name = \"Specimen\"  \nfield_names = get_entity_fields(entity_name, auth)\nprint(f\"Available fields for {entity_name}:\", field_names)\n</code></pre>"},{"location":"workflows/query/#32-filter-patients-of-interest-researchsubject-participants","title":"3.2 Filter Patients of Interest (ResearchSubject Participants)","text":"<pre><code>researchsubject_query = \"\"\"\nquery ($filter: JSON) {\n  researchsubject(filter: $filter, first: 10000) {\n            id\n            patient_id\n            condition_diagnosis\n  }\n}\n\"\"\"\n\nresearchsubject_variables = {\n    \"filter\": {\n        \"IN\": {\n            \"condition_diagnosis\": [\"Infiltrating duct carcinoma, NOS\"]\n        }\n    }\n}\nresearchsubject_response = Gen3Query.graphql_query(\n    Gen3Query(auth),\n    query_string=researchsubject_query,\n    variables=researchsubject_variables\n)\npatient_ids = [p[\"patient_id\"] for p in researchsubject_response[\"data\"][\"researchsubject\"]]\n</code></pre>"},{"location":"workflows/query/#33-filter-specimens-of-interest-from-patient-ids","title":"3.3 Filter Specimens of Interest from Patient Ids","text":"<pre><code>def execute_query(auth, query_string, variables=None):\n    \"\"\"perform guppy query\"\"\"\n    return Gen3Query.graphql_query(Gen3Query(auth), query_string=query_string, variables=variables)\n\ndef get_specimens(auth, patient_ids):\n    \"\"\"Fetch specimens associated with patient ids\"\"\"\n    query = \"\"\"\n    query ($filter: JSON) {\n        specimen (filter: $filter, first: 10000) {\n            id\n            patient_id\n            specimen_id\n            &lt;other_sample_metadata&gt;\n        }\n    }\n    \"\"\"\n    variables = {\"filter\": {\"IN\": {\"patient_id\": patient_ids}}}\n    response = execute_query(auth, query, variables)\n    specimens = defaultdict(list)\n    for specimen in response[\"data\"][\"specimen\"]:\n        if specimen[\"gene\"]:\n            specimens[specimen[\"patient_id\"]].append(specimen)\n    return specimens\ndat = get_specimens(auth, patient_ids)\nspecimen_ids = [d[1][0]['id'] for d in dat.items()]\n</code></pre>"},{"location":"workflows/query/#34-filter-files-associated-with-specimens-of-interest","title":"3.4 Filter Files Associated with Specimens of Interest","text":"<pre><code>def get_files(auth, specimen_ids):\n    \"\"\"Fetch files associated with specimens.\"\"\"\n    query = \"\"\"\n    query ($filter: JSON) {\n        file (filter: $filter, first: 10000) {\n            id\n            specimen_id\n            sample_type\n        }\n    }\n    \"\"\"\n    \"\"\"\n    variables = {\n    \"filter\": {\n        \"AND\": [\n            {\n                \"IN\": {\n                    \"specimen_id\": specimen_ids\n                }\n            },\n            {\n                \"LIKE\": {\n                    \"sample_type\": [\"%Primary Tumor%\"]\n\n                }\n            }\n        ]\n    }}\n    \"\"\"\n\n    variables = {\"filter\": {\"IN\": {\"specimen_id\": specimen_ids}}}\n    response = execute_query(auth, query, variables)\n    return response[\"data\"][\"file\"]\n\nfile_data = get_files(auth, specimen_ids)\n</code></pre>"},{"location":"workflows/query/#simple-end-to-end-workflow","title":"Simple end to end workflow:","text":""},{"location":"workflows/query/#query-examplegraphql","title":"Query (<code>example.graphql</code>)","text":"<pre><code>query ExampleQuery {\n  files: file(first: 1000) {\n    file_name\n    project_id\n    id\n  }\n  patients: patient(first: 1000) {\n    name\n    project_id\n    id\n  }\n  observations: observation(first: 1000) {\n    code\n    project_id\n    id\n  }\n}\n</code></pre>"},{"location":"workflows/query/#script-examplepy","title":"Script (<code>example.py</code>)","text":"<pre><code>from gen3.auth import Gen3Auth\nfrom gen3.query import Gen3Query\nimport json\n\nauth = Gen3Auth()\n\nquery = ''\n\n# Read in Example Query\nwith open('example.graphql') as f:\n    query = f.read()\n\nresponse = Gen3Query.graphql_query(Gen3Query(auth), query_string=query)\n\nformatted = json.dumps(response, indent=2)\n\nprint(formatted)\n\n# &gt;&gt;&gt; Example Output\n</code></pre>"},{"location":"workflows/query/#output","title":"Output","text":"<pre><code>$ python example.py\n{\n  \"data\": {\n    \"files\": [\n      {\n        \"file_name\": \"example.bam\",\n        \"project_id\": \"cbds-example\",\n      },...\n    ],\n    \"patients\": [\n      {\n        \"name\": \"Example Name\",\n        \"project_id\": \"cbds-example\",\n      },...\n    ],\n    \"observations\": [\n      {\n        \"code\": \"Example Code\",\n        \"project_id\": \"cbds-example\",\n      },...\n    ]\n  }\n}\n</code></pre>"},{"location":"workflows/query/#additional-resources","title":"Additional Resources \ud83d\udcda","text":"<ul> <li> <p>Gen3 SDK Documentation</p> </li> <li> <p>Gen3 SDK Repo</p> </li> <li> <p>Gen3 SDK PyPi</p> </li> <li> <p>Guppy Syntax Docs</p> </li> </ul>"},{"location":"workflows/quick-start-guide/","title":"Quickstart Guide","text":"<p>Note</p> <p>The tools listed here are under development and may be subject to change.</p>"},{"location":"workflows/quick-start-guide/#about","title":"About","text":"<p>gen3 tracker, or g3t, is a command line tool for the ACED-IDP platform. It provides a set of utilities for users to upload data to and download data from the platform. The following tutorial will walk you through the steps for two different use cases:</p> <ol> <li>Uploading files for a new project to the platform</li> <li>Downloading an existing project from the platform</li> </ol> <p>Each step will outline the command to execute followed by a brief description of the command's functionality.</p>"},{"location":"workflows/quick-start-guide/#requirements","title":"Requirements","text":"<p>Please ensure you have completed the following setup from the Requirements page:</p> <ol> <li>Installed gen3-client</li> <li>Configured a gen3-client profile with credentials</li> <li>Installed gen3-tracker</li> </ol> <p>To confirm all dependencies are set up as expected, run</p> <pre><code>g3t --profile &lt;your_g3t_profile_name&gt; ping\n</code></pre> <p>You should get a message like this</p> <p>msg: 'Configuration OK: Connected using profile:aced' endpoint: https://aced-idp.org username: someone@example.com</p> <p>along with the set of projects you have been provided access to.</p>"},{"location":"workflows/quick-start-guide/#general-usage","title":"General Usage","text":"<pre><code>g3t [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>g3t is built on git, so many commands behave similarly to git with some key differences. These differences will be outlined for each step in the submission process.</p>"},{"location":"workflows/quick-start-guide/#1-upload-data-to-a-newly-approved-project","title":"1. Upload Data to a Newly Approved Project","text":"<p>The first use case we will cover is how to add data to a new project on the ACED-IDP.</p> <p>Note</p> <p>The following examples will use the <code>aced</code> program with a project called <code>myproject</code> and an <code>aced</code> g3t profile.</p>"},{"location":"workflows/quick-start-guide/#check-project-permissions","title":"Check Project Permissions","text":"<p>To start, check what projects you have access to using the command</p> <pre><code>g3t projects ls\n</code></pre> <p>Check that you have permission to edit <code>aced-myproject</code>. This is what allows you to push data up to the platform. If you do not have the correct permissions, please contact a system administrator.</p>"},{"location":"workflows/quick-start-guide/#specify-a-gen3-profile","title":"Specify a gen3 Profile","text":"<p>For most g3t commands, you need to specify the gen3-client profile you want to use. This ensures that you are uploading projects to the right platform with the right credentials. There are two ways to set your profile...</p> <p>To set a profile using an environmental variable: <pre><code>export G3T_PROFILE=aced\n</code></pre></p> <p>To pass the profile as a flag to the <code>ping</code> command for example:</p> <pre><code>g3t --profile aced ping\n</code></pre> <p>For the rest of the tutorial, we will assume you have exported a <code>G3T_PROFILE</code> environment variable so we don't have to use the <code>--profile</code> flag each time.</p>"},{"location":"workflows/quick-start-guide/#initialize-a-new-project","title":"Initialize a new project","text":"<p>To initialize your new project locally, you can use <code>g3t init</code></p> <pre><code>mkdir aced-myproject\ncd aced-myproject\ng3t init aced-myproject\n</code></pre> <ul> <li>Similar to <code>git init</code>, this command creates a new project in the current directory</li> <li>Within the project, there are a couple important directories...<ul> <li><code>MANIFEST/</code>: stores file metadata entries</li> <li><code>META/</code>: stores metadata converted into the FHIR standard</li> <li><code>.g3t/</code>: hidden, stores and manages g3t state for the project</li> </ul> </li> <li>The project ID is <code>aced-myproject</code> made from the program name <code>aced</code> and project name <code>myproject</code>. Specifically,<ul> <li>Program name: is predefined by the institution, defining what remote data buckets and endpoints you have access to</li> <li>Project name: must be unique within the server, be alphanumeric, and contain no spaces or hyphens</li> </ul> </li> <li>For more information, see creating a project</li> </ul>"},{"location":"workflows/quick-start-guide/#add-files-to-the-manifest","title":"Add files to the manifest","text":"<p>Once your project is initialized, you can add files to the project's manifest. For example, let's say you have tsv files in a <code>folder/</code> directory within your current repository. Each of the tsv files are associated with a particular subject, say <code>patient_1</code> and <code>patient_2</code>. To add them using <code>g3t add</code>,</p> <pre><code>g3t add folder/file.tsv --patient patient_1\ng3t add folder/file2.tsv --patient patient_2\n</code></pre> <ul> <li>Each <code>g3t add</code> above creates a metadata entry for the specified data file, automatically calculating metadata like the file's md5sum, type, date modified, size, and path.<ul> <li>Just as a ship's manifest is an inventory of its cargo, the <code>MANIFEST/</code> directory is an inventory for each file's metadata</li> <li>Each metadata entry is stored as a  <code>.dvc</code> file in the <code>MANIFEST</code> directory, where the dvc file path mirrors the original file path</li> <li>Example: <code>folder/file.tsv</code> creates a <code>MANIFEST/folder/file.tsv.dvc</code> entry</li> </ul> </li> <li>Using the patient flag is one way to associate a file with a particular subject, in this case associating each file with a specified patient identifier.</li> <li><code>g3t add</code> varies from <code>git add</code>, as the <code>.dvc</code> file is what gets staged rather than the potentially large data file</li> <li>Multiple files can be added at the same time by wrapping a wildcard string in quotes, for example, <code>g3t add \"*.csv\"</code>.</li> <li>For more information on usage, such as adding entries for remote files or how to associate files with a sample, see adding files</li> </ul>"},{"location":"workflows/quick-start-guide/#create-metadata","title":"Create metadata","text":"<p>Now that your files have been staged with metadata entries, you can create FHIR-compliant metadata using the <code>g3t meta init</code> command</p> <pre><code>g3t meta init\n</code></pre> <ul> <li>Using the file metadata entries created by the <code>g3t add</code> command, <code>g3t meta init</code> creates FHIR-compliant metadata files in the <code>META/</code> directory, where each file corresponds to a FHIR resource. At a minimum, the directory will contain:</li> </ul> File Contents ResearchStudy.ndjson Description of the project DocumentReference.ndjson File information <ul> <li>Additional metadata files for patient, specimen, and other entities will be generated based on options provided to the <code>add</code> command.</li> </ul> File Contents Patient.ndjson Patient information ResearchSubject.ndjson Enrollment information Specimen.ndjson Sample information <ul> <li><code>meta init</code> is a good example of where g3t differs from git! While you might go from <code>git add</code> straight to <code>git commit</code> in a git workflow, we have to do <code>g3t add</code> &gt; <code>g3t meta init</code> &gt; <code>g3t commit</code> to track both the files and each file's metadata in g3t.</li> <li><code>meta init</code> focuses on creating metadata specific to the files you added. For your particular use case, you may also want to supply your own FHIR data, see adding FHIR metadata</li> </ul>"},{"location":"workflows/quick-start-guide/#check-that-the-metadata-is-valid","title":"Check that the metadata is valid","text":"<p>To ensure that the FHIR data has been properly formatted, you can call <code>g3t meta validate</code>.</p> <pre><code>g3t meta validate\n</code></pre> <ul> <li>The system will print summary counts and informative messages if the metadata is invalid.</li> </ul>"},{"location":"workflows/quick-start-guide/#check-that-the-expected-files-are-queued-for-upload","title":"Check that the expected files are queued for upload","text":"<p>You can double-check that all of your files have been staged with <code>g3t status</code></p> <pre><code>g3t status\n</code></pre>"},{"location":"workflows/quick-start-guide/#commit-files","title":"Commit files","text":"<p>With all checks complete, you can commit the metadata we created using <code>g3t commit</code>.</p> <pre><code>g3t commit -m \"adding tsv metadata\"\n</code></pre> <ul> <li>Like git, this command bundles the staged files into a single set of changes.</li> <li>The <code>-m</code> flag adds a commit message to the changes </li> <li>If the commit is successful, you will see a summary of the changes logged</li> <li>As a reminder, the files that are committed to git are the FHIR metadata in META/ and the .dvc entries in MANIFEST/, not the data files themselves</li> <li>See publishing a project for more info</li> </ul>"},{"location":"workflows/quick-start-guide/#push-to-aced-idp","title":"Push to ACED-IDP","text":"<p>To submit the files and metadata to the data platform, we can use <code>g3t push</code></p> <pre><code>g3t push\n</code></pre> <ul> <li>This command launches a job to upload project data to the specified data platform.</li> <li>Specifically, it...<ol> <li>Checks that all files are committed before pushing</li> <li>Checks that the <code>META/</code> metadata is valid</li> <li>Indexes the data files using the file metadata in the <code>MANIFEST/</code> directory</li> <li>Uploads the FHIR metadata in the <code>META/</code> directory into our databases</li> </ol> </li> <li>A push will fail if no new files are being submitted. If you need to update existing files in the manifest or update the FHIR metadata, use the <code>--overwrite</code> option to force an upload.</li> <li>A job is successful if you get a green success message.</li> <li>For other publishing options and specialized use cases, see publishing a project</li> </ul>"},{"location":"workflows/quick-start-guide/#view-the-data-on-the-platform","title":"View the Data on the Platform","text":"<p>Congratulations, you have submitted data to the platform! To check that your data was uploaded, login and navigate to the Exploration page on aced-idp.org!</p>"},{"location":"workflows/quick-start-guide/#2-download-data-from-a-project-on-aced-idp","title":"2. Download Data from a Project on ACED-IDP","text":"<p>Sometimes you might want the most recent version of a data project that has already been published to the platform. To download the metadata for an existing project, use the <code>g3t clone</code> command.</p> <pre><code>g3t clone aced-myproject\n</code></pre> <ul> <li>The clone command will download the metadata associated with the project into a new directory</li> <li>Specifically, it downloads the metadata <code>.dvc</code> entries in <code>MANIFEST/</code> and the FHIR-compliant metadata in <code>META/</code> </li> </ul> <p>To retrieve the actual data files described by manifest as opposed to just the file metadata, use the pull command.</p> <pre><code>mkdir aced-myproject\ncd aced-myproject\ng3t init aced-myproject\ng3t pull\n</code></pre> <ul> <li>The pull command will retrieve the actual data files associated with the metadata.</li> </ul> <p>To download only a subset of files, refer to the downloads page. For more information on other commands or use cases, see the Use Cases &amp; Workflows section.</p>"},{"location":"workflows/status/","title":"g3t status","text":""},{"location":"workflows/status/#show-the-working-tree-status","title":"Show the working tree status","text":"<p>The <code>g3t status</code> command is used to view the state of your working directory. It functions the same as <code>git status</code>, providing info on: </p> <ul> <li>Untracked files: files that have not been staged</li> <li>Changes to be committed: files that have been staged (added) but not committed</li> </ul> <pre><code> g3t status --help\nUsage: g3t status\n\n  Show the working tree status.\n</code></pre>"},{"location":"workflows/tabular/","title":"Create Tabular Metadata","text":"<p>Note</p> <p>The tools listed here are under development and may be subject to change.</p>"},{"location":"workflows/tabular/#creating-tabular-data","title":"Creating Tabular Data","text":"<p>On the Explorer page on the data platform, FHIR metadata gets flattened out from a graph structure to a tabular format so that it is more easily visualized by users. For complex use cases, you might want to see what the flattened version of the metadata looks like before submitting the data through <code>g3t push</code>. This can be done using <code>g3t meta dataframe</code></p> <pre><code>Usage: g3t meta dataframe [OPTIONS] {Specimen|DocumentReference|ResearchSubjec\n                          t|MedicationAdministration|GroupMember}\n                          [DIRECTORY_PATH] [OUTPUT_PATH]\n\n  Render a metadata dataframe.\n\n  DIRECTORY_PATH: The directory path to the metadata.\n  OUTPUT_PATH: The output path for the dataframe. Optional, defaults to \"{Specimen|DocumentReference|ResearchSubject|MedicationAdministration|GroupMember}.csv\"\n\nOptions:\n  --dtale  Open the graph in a browser using the dtale package for interactive\n           data exploration. Requires pip install dtale\n  --debug\n  --help   Show this message and exit\n</code></pre>"}]}